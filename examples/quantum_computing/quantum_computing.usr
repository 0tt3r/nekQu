c----------------------------------------------------------------------
c
c  USER SPECIFIED ROUTINES:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine useriniQ
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'QUANT'
      include 'mpif.h'

      integer ii,jj,kk,numberOfQubits
      
      integer qubit(3,10)       !qubit stores all of the handles
                          !qubit(1,ii) is the annihilation operator for qubit ii
                          !qubit(2,ii) is the creation operator for qubit ii
                          !qubit(3,ii) is the number operator for qubit ii
      integer couple(2,10,10)  !couple(1,i,j) = q_i^t q_j
                               !couple(2,i,j) = q_i q_j^t

      real eV,debye,gamma_pi,gamma_di,gamma_s,omega,g_couple
      real gateTimeStep,gateTime,zeroOut
      eV       = 27.21140                ! energy Eh  
      debye     = 0.3934303070      

      zeroOut  = 1.0
      gamma_pi = 0*1.9d-7/eV*zeroOut
      gamma_di = 0*2.0d-3/eV*zeroOut

      omega    = 2.05/eV*zeroOut
      
      g_couple  = 0*1e-3/eV*zeroOut
      
      numberOfQubits = 3


      timeunit= 2.418884326505e-17        ! hbar/Eh(hartree) SI unit       
      timemax     = 10e-13/timeunit
      nqstep      = 5000

      call quantum_setup_initialize()


      calc_concurrence = .true.
      useGates = .true.

      !Create all of the ops
      do ii=1,numberOfQubits
         call quantum_create_op(2,qubit(1,ii),qubit(2,ii),qubit(3,ii))
      enddo

      call quantum_finalize_op_csr()
      !combine ops for coupling terms
      !qubit(1,i) = q_i, qubit(2,i) = q_i^t, qubit(3,i) = q_i^t q_i
      do ii=1,numberOfQubits
         do jj=ii+1,numberOfQubits
            call quantum_combine_op_csr(qubit(2,ii),qubit(1,jj),1,
     $           couple(1,ii,jj))
            call quantum_combine_op_csr(qubit(1,ii),qubit(2,jj),1,
     $           couple(2,ii,jj))
         enddo
      enddo

      !Oscillator terms
      do ii=1,numberOfQubits
         call quantum_add_to_ham_csr(qubit(3,ii),omega,0)      
      enddo

      !Coupling terms
      do ii=1,numberOfQubits
         do jj=ii+1,numberOfQubits
            call quantum_add_to_ham_csr(couple(1,ii,jj),-g_couple,0)
            call quantum_add_to_ham_csr(couple(2,ii,jj),-g_couple,0)
         enddo
      enddo

      call quantum_ham_finalize_csr()

      !Lindblad terms
      do ii=1,numberOfQubits
         call quantum_lin_add(qubit(1,ii),qubit(3,ii),-gamma_pi/2)
         call quantum_lin_add(qubit(3,ii),qubit(3,ii),-gamma_di)
      enddo

      call quantum_lin_finalize()
      debug         = 1


      gateTime     = 1e-13
      gateTimeStep = 1e-13/timeunit
      !QFT below
      do ii=1,numberOfQubits
      !6 = hadamard gate
         call quantum_add_gate(ii,numberOfQubits,6,gateTime)
         print*,'ii',ii,gateTime
         gateTime = gateTime + gateTimeStep
         print*,'ii',ii,gateTime
         do jj=ii+1,numberOfQubits
            call quantum_add_crk (jj,ii,numberOfQubits,2,gateTime)
            print*,'jj',jj,gateTime
            gateTime = gateTime + gateTimeStep
            print*,'jj',jj,gateTime
         enddo
      enddo


      call cem_quantum3_propagation_rk

      return
      end



c-----------------------------------------------------------------------
      subroutine usertimedep(pulse)
      implicit none
      include 'SIZE'
      include 'QUANT'
      real pulse
      real alpha
      
      pulse = 0.0

      return
      end

c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'QUANT'


c ... compute errors


      if (iqstep.le.10.or.mod(iqstep,100).eq.0) then

c$$$        cpu_t1  = glsum(qrtime1,1)/(np*iqstep) ! total cpu/(np*iqstep)
c$$$        cpu_t2  = glsum(qrtime2,1)/(np*iqstep) ! hamiltonian/(np*iqstep)
c$$$        cpu_t3  = glsum(qrtime3,1)/(np*iqstep) ! linblad/(np*iqstep)
c$$$        cpu_t4  = glsum(qrtime4,1)/(np) ! fourier/(np)
c$$$
c$$$        comm_t1 = glsum(qctime1,1)/(np*iqstep) ! total gs_op/(np*iqstep)
c$$$        comm_t3 = glsum(qctime3,1)/(np*iqstep) ! total get  /(np*iqstep)

        if (nid.eq.0) then

        if(iqstep.eq.1) write(6,*)'iqstep nstate
     $gs_op get total ham lin fourier gs_op get total ham lin fourier'
         write(6,91) iqstep,nstate, 
     $               qctime1,qctime3,
     $               qrtime1,qrtime2, qrtime3, qrtime4,
     $               comm_t1,comm_t3,              
     $               cpu_t1,cpu_t2,cpu_t3,cpu_t4              

 91      format(/,i10,i10,12e10.3,' CPU: L2  '  )

        endif ! nid=0
      endif

      return
      end

c-----------------------------------------------------------------------
      subroutine userchk_acc
      include 'SIZE'
      include 'QUANT'


c ... compute errors


      if (iqstep.le.10.or.mod(iqstep,100).eq.0) then

c$$$        cpu_t1  = glsum(qrtime1,1)/(np*iqstep) ! total cpu/(np*iqstep)
c$$$        cpu_t2  = glsum(qrtime2,1)/(np*iqstep) ! hamiltonian/(np*iqstep)
c$$$        cpu_t3  = glsum(qrtime3,1)/(np*iqstep) ! linblad/(np*iqstep)
c$$$        cpu_t4  = glsum(qrtime4,1)/(np) ! fourier/(np)
c$$$
c$$$        comm_t1 = glsum(qctime1,1)/(np*iqstep) ! total gs_op/(np*iqstep)
c$$$        comm_t3 = glsum(qctime3,1)/(np*iqstep) ! total get  /(np*iqstep)

        if (nid.eq.0) then

        if(iqstep.eq.1) write(6,*)'iqstep level numqd numsp nstate
     $gs_op get total ham lin fourier gs_op get total ham lin fourier'
         write(6,91) iqstep, level,numqd,numsp,nstate, 
     $               qctime1,qctime3,
     $               qrtime1,qrtime2, qrtime3, qrtime4,
     $               comm_t1,comm_t3,    
     $               cpu_t1,cpu_t2,cpu_t3,cpu_t4    

 91      format(/,i10,3i7,i10,12e10.3,' CPU: L2  '  )

        endif ! nid=0
      endif

      return
      end 

c-----------------------------------------------------------------------
