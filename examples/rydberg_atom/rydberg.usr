c----------------------------------------------------------------------
c
c  USER SPECIFIED ROUTINES:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine useriniQ
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'QUANT'
      include 'mpif.h'

      !Create variables to store operators
      !p = +, m = -

      integer a,at,an,a_at,b,bt,bn,bt_a,b_at,b_a_bt,ierr
      
      integer N_th,num_phon,sigma_z !number of phonons
      !parameters
      real w_m,Q,prefactor,w_atom,rabi_freq,ev
      real tmpint,fluence,c_speed,eesu_per_au

      !Units
      real kHz,MHz,GHz,THz,ns,us,d,gamma_di,g,delta


      eV       = 27.21140                ! energy Eh  
      GHz = 1.519827e-7 !In AU
      MHz = GHz*1e-3
      kHz = MHz*1e-3
      THz = GHz*1e3
      pi          = 4.*ATAN(1.0)      

      
      timeunit= 2.418884326505e-17 !in a.u.
      ns = 1e-9/timeunit
      us = 1e-6/timeunit




      call quantum_setup_initialize()
      !Read the simple input
      if(nid.eq.0) then
      open(unit=2,file='quantInput')
      read(2,*) pulse_omega_0
      close(unit=2)
      endif

#ifdef MPI
      call MPI_BCAST(pulse_omega_0,1,MPI_REAL8,0,MPI_COMM_WORLD,IERR)
#else
      np=1
      nid=0
#endif      

      w_m = 5.4*GHz
      Q   = 10**4  !resonator quality factor
      rabi_freq = 3*MHz
      delta      = 100*MHz
      g          = sqrt(rabi_freq**2 + delta**2)
      w_atom = 5.5*GHz !Atom frequency
!      w_atom = 2.05/eV
      d = 7980 !In atomic units

      N_th = 150 !Thermal population


!Initial state 1/3 1/3 1/3 in ground state 10 in phonon
!     For n=16
!      timemax     = 0.0003e-6/timeunit
!      nqstep      = 90

!       for n=32
c$$$      timemax     = 0.3e-6/timeunit
c$$$      nqstep      = 18000

      timemax     = 2e-6/timeunit
      nqstep      = int(2e-6/1e-11)

      num_phon = 32

      pulse_omega_0 = pulse_omega_0*GHz
      pulse_omega_0 = w_atom
      pulse_duration = 1e-9/timeunit
      pulse_t_0      = 1e-9/timeunit
      Emin = pulse_omega_0-0.5*GHz
      Emax = pulse_omega_0+0.5*GHz
      nEh = 100


      gamma_di = 30*MHz

!      pulse_omega_0  = w_atom
!      pulse_duration = 100e-1/timeunit
!      timemax     = 45e-9/timeunit
!      nqstep      = 50000
!      pulse_t_0     = -1e-9/timeunit

c$$$      Emax = 2.14/eV
c$$$      Emin = 1.94/eV
c$$$      nEh  = 100

      fluence = 1e-20*1d7
      c_speed = 2.99792458d10 !cm/s

      eesu_per_au = 5.14220652d17 / c_speed

      tmpint = 5e-1 * sqrt(5d-1 * pi/(2d0*log(2d0)/pulse_duration**2))
     $     * (1e0 + exp(-5e-1 * pulse_omega_0 ** 2 / 
     $     (2d0*log(2d0)/pulse_duration**2)))*timeunit
      energy0_pls =sqrt(4*pi*fluence/(c_speed*tmpint))
      energy0_pls = energy0_pls / eesu_per_au

      print*,'energy0_pls',energy0_pls

!      ifpulse = .true.
!      rwa     = .true.
      print_during_run = .true.

!     Create basic operators

      call quantum_create_op(num_phon,a,at,an) 
      call quantum_create_op(2,b,bt,bn)
!      call quantum_set_minimum_op(1,an)
      call quantum_finalize_op_csr()

      call quantum_combine_op_csr(a,at,1,a_at)
      call quantum_combine_op_csr(b,bt,0,b_a_bt)

       !Oscillator terms
      !w_m at a
      call quantum_add_to_ham_csr(an,w_m,0)      
      call quantum_create_sigma_z(bn,sigma_z)
      !w_atom bt b
      call quantum_add_to_ham_csr(bn,w_atom,0)
!      call quantum_add_to_ham_csr(sigma_z,w_atom/2,0)

      call quantum_add_to_ham_csr(b_a_bt,-d,1)

      call quantum_combine_op_csr(bt,a,1,bt_a)
      call quantum_combine_op_csr(b,at,1,b_at)


      call quantum_add_to_ham_csr(bt_a,g,0)
      call quantum_add_to_ham_csr(b_at,g,0)

c$$$      call quantum_add_to_ham_csr(bt_a,rabi_freq,0)
c$$$      call quantum_add_to_ham_csr(b_at,rabi_freq,0)

      call quantum_ham_finalize_csr()

      call quantum_observable(b_a_bt,d)
      !Lindblad terms
      
      
      !resonator dissipation - What about this factor of 2?
      prefactor = (w_m/(2*Q)*(N_th+1))
      print*,prefactor
      call quantum_lin_add(a,an,-prefactor)
!      print*,'after lin_add'
      prefactor = (w_m/(2*Q)*(N_th))
      print*,prefactor
      call quantum_lin_add(at,a_at,-prefactor)
      call quantum_lin_add(b,bn,-gamma_di)      
!      call quantum_lin_add_trans(a,an,-prefactor)
!      print*,'after lin_add2'

      call quantum_lin_finalize()
!      call cem_quantum3_propagation_exp
      call cem_quantum3_propagation_rk

      return
      end

c-----------------------------------------------------------------------
      subroutine usertimedep(pulse)
      implicit none
      include 'SIZE'
      include 'QUANT'
      real pulse
      real alpha

      alpha = 2 * log(2.0)/ (pulse_duration)**2
      if(rwa.eqv..true.) then
         pulse = energy0_pls
     $        /2.0*exp(-alpha*(time-pulse_t_0)**2)
      else
         pulse = 1e-9*exp(-alpha*(time-pulse_t_0)**2)
     $        *cos(pulse_omega_0*time)
      endif

!      if(nid.eq.1) then
!      print*,'1',time*timeunit,pulse
 !     print*,'2',eps_med,c_speed,eesu_per_au,timeunit,pi,time

!      endif
      return
      end

c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'QUANT'


c ... compute errors


      if (iqstep.le.10.or.mod(iqstep,100).eq.0) then

c$$$        cpu_t1  = glsum(qrtime1,1)/(np*iqstep) ! total cpu/(np*iqstep)
c$$$        cpu_t2  = glsum(qrtime2,1)/(np*iqstep) ! hamiltonian/(np*iqstep)
c$$$        cpu_t3  = glsum(qrtime3,1)/(np*iqstep) ! linblad/(np*iqstep)
c$$$        cpu_t4  = glsum(qrtime4,1)/(np) ! fourier/(np)
c$$$
c$$$        comm_t1 = glsum(qctime1,1)/(np*iqstep) ! total gs_op/(np*iqstep)
c$$$        comm_t3 = glsum(qctime3,1)/(np*iqstep) ! total get  /(np*iqstep)

        if (nid.eq.0) then

        if(iqstep.eq.1) write(6,*)'iqstep nstate
     $gs_op get total ham lin fourier gs_op get total ham lin fourier'
         write(6,91) iqstep,nstate, 
     $               qctime1,qctime3,
     $               qrtime1,qrtime2, qrtime3, qrtime4,
     $               comm_t1,comm_t3,              
     $               cpu_t1,cpu_t2,cpu_t3,cpu_t4              

 91      format(/,i10,i10,12e10.3,' CPU: L2  '  )

        endif ! nid=0
      endif

      return
      end

c-----------------------------------------------------------------------
      subroutine userchk_acc
      include 'SIZE'
      include 'QUANT'


c ... compute errors


      if (iqstep.le.10.or.mod(iqstep,100).eq.0) then

c$$$        cpu_t1  = glsum(qrtime1,1)/(np*iqstep) ! total cpu/(np*iqstep)
c$$$        cpu_t2  = glsum(qrtime2,1)/(np*iqstep) ! hamiltonian/(np*iqstep)
c$$$        cpu_t3  = glsum(qrtime3,1)/(np*iqstep) ! linblad/(np*iqstep)
c$$$        cpu_t4  = glsum(qrtime4,1)/(np) ! fourier/(np)
c$$$
c$$$        comm_t1 = glsum(qctime1,1)/(np*iqstep) ! total gs_op/(np*iqstep)
c$$$        comm_t3 = glsum(qctime3,1)/(np*iqstep) ! total get  /(np*iqstep)

        if (nid.eq.0) then

        if(iqstep.eq.1) write(6,*)'iqstep level numqd numsp nstate
     $gs_op get total ham lin fourier gs_op get total ham lin fourier'
         write(6,91) iqstep, level,numqd,numsp,nstate, 
     $               qctime1,qctime3,
     $               qrtime1,qrtime2, qrtime3, qrtime4,
     $               comm_t1,comm_t3,    
     $               cpu_t1,cpu_t2,cpu_t3,cpu_t4    

 91      format(/,i10,3i7,i10,12e10.3,' CPU: L2  '  )

        endif ! nid=0
      endif

      return
      end 

c-----------------------------------------------------------------------
