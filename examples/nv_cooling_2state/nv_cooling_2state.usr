c----------------------------------------------------------------------
c
c  USER SPECIFIED ROUTINES:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine useriniQ
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'QUANT'
      include 'mpif.h'

      !Create variables to store operators
      !p = +, m = -
      !gpgp => |g+><g+|, gmgm => |g-><g-|, g0g0 => |g0><g0|, etc
      !nv hold all the vector state:
      !nv(1) = |g0> = g0, nv(2)=|e+>=ep, nv(3)=|e->=em

      integer nv,nvt,nvn,nv_p_nvt
      integer a,at,an,a_at,a_p_at
      integer sig_g1,sig_g2,sig_e1,sig_e2
      
      
      integer N_th,num_phon !number of phonons
      !parameters
      real w_m,E_e,E_s,D_e,Omega,gamma_eff,lambda_eff,lambda_s
      real keg,Q,prefactor,alpha

      !Units
      real kHz,MHz,GHz,THz,Hz,ns,us
      !Read the simple input
c$$$      if(nid.eq.0) then
c$$$      open(unit=2,file='quantInput')
c$$$      read(2,*) fluence,g_couple,g_couple2,g_couple3
c$$$      close(unit=2)
c$$$      endif
c$$$      call MPI_BCAST(fluence,1,MPI_REAL8,0,MPI_COMM_WORLD,IERR)
c$$$      call MPI_BCAST(g_couple,1,MPI_REAL8,0,MPI_COMM_WORLD,IERR)
c$$$      call MPI_BCAST(g_couple2,1,MPI_REAL8,0,MPI_COMM_WORLD,IERR)
c$$$      call MPI_BCAST(g_couple3,1,MPI_REAL8,0,MPI_COMM_WORLD,IERR)
      GHz = 1.519827e-7 !In AU
      MHz = GHz*1e-3
      kHz = MHz*1e-3
      THz = GHz*1e3
      Hz  = kHz*1e-3
      pi          = 4.*ATAN(1.0)      

      
      timeunit= 2.418884326505e-17 !in a.u.
      ns = 1e-9/timeunit
      us = 1e-6/timeunit
      
      w_m = 1*GHz !Mechanical resonator frequency
      E_e = 480*THz !NV center excited state energy
      E_s = 370*THz !Nv center singlet energy
      D_e = 1.52*GHz !NV excited state zero field splitting
      Omega = 10*MHz !Magnetic driving field
      gamma_eff = 145*MHz !Effective dissipation rate
      lambda_s  = 14.1*kHz
      alpha      = 0.0135
      lambda_eff = lambda_s*sqrt(alpha*5.6*10**5)
      keg = 100*MHz !Relaxation from excited to ground
      Q   = 10**3  !Mechanical resonator quality factor
!      Q   = 10**12 !Q factor artifical - 3 phonons

!      N_th = 6547 ! Room temperature
      N_th = 1   !Very cold

      
!Initial state 1/3 1/3 1/3 in ground state 10 in phonon
!     For n=16
!      timemax     = 0.0003e-6/timeunit
!      nqstep      = 90

!       for n=32
c$$$      timemax     = 0.3e-6/timeunit
c$$$      nqstep      = 18000

      timemax     = 1.5e-6/timeunit
      nqstep      = 45000

      num_phon = 8 

      call quantum_setup_initialize()

!     Create basic operators

      call quantum_create_op(num_phon,a,at,an)  
      call quantum_create_op(2,nv,nvt,nvn)


      call quantum_finalize_op_csr()


      call quantum_combine_op_csr(a,at,1,a_at)

!Oscillator terms
      !w_m at a
      call quantum_add_to_ham_csr(an,w_m,0)      

      !w_m |e><e|
      call quantum_add_to_ham_csr(nvn,w_m,0)
      
      call quantum_combine_op_csr(a,at,0,a_p_at)
      call quantum_combine_op_csr(nv,nvt,0,nv_p_nvt)
      !Sigma_e term = lambda_eff (|e><g| + |g><e|)(a+at)
      call quantum_combine_op_csr(nv_p_nvt,a_p_at,1,sig_e1)
      call quantum_add_to_ham_csr(sig_e1,lambda_eff,0)      


      call quantum_ham_finalize_csr()

      !Lindblad terms
      !L_{i,f} = -2*|f><i|rho|i><f| + |i><i|rho + rho|i><i|
      !Translated to lin add:
      !      quantum_lin_add(|f><|i|,|i><i|,scalar)

      !Gamma_eff terms
      !-Gamma_eff/2 *  L_{e,g}
      call quantum_lin_add(nv,nvn,-gamma_eff/2)
      

      !Mechanical resonator dissipation
      prefactor = w_m/(2*Q)*(N_th+1)
      call quantum_lin_add(a,an,-prefactor)
!      print*,'after lin_add'
      prefactor = w_m/(2*Q) *N_th
      call quantum_lin_add(at,a_at,-prefactor)

!      call quantum_lin_add_trans(a,an,-prefactor)
!      print*,'after lin_add2'

      call quantum_lin_finalize()
!      call cem_quantum3_propagation_exp
      call cem_quantum3_propagation_rk

      return
      end

c-----------------------------------------------------------------------
      subroutine usertimedep(pulse)
      implicit none
      include 'SIZE'
      include 'QUANT'
      real pulse
      real alpha

      alpha = 2 * log(2.0)/ (pulse_duration)**2
      if(rwa.eqv..true.) then
         pulse = 100
      else
         pulse = energy0_pls/2.0*exp(-alpha*(time-pulse_t_0)**2)
     $        *cos(pulse_omega_0*time)
      endif

!      if(nid.eq.1) then
!      print*,'1',time*timeunit,pulse
 !     print*,'2',eps_med,c_speed,eesu_per_au,timeunit,pi,time

!      endif
      return
      end

c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'QUANT'


c ... compute errors


      if (iqstep.le.10.or.mod(iqstep,100).eq.0) then

c$$$        cpu_t1  = glsum(qrtime1,1)/(np*iqstep) ! total cpu/(np*iqstep)
c$$$        cpu_t2  = glsum(qrtime2,1)/(np*iqstep) ! hamiltonian/(np*iqstep)
c$$$        cpu_t3  = glsum(qrtime3,1)/(np*iqstep) ! linblad/(np*iqstep)
c$$$        cpu_t4  = glsum(qrtime4,1)/(np) ! fourier/(np)
c$$$
c$$$        comm_t1 = glsum(qctime1,1)/(np*iqstep) ! total gs_op/(np*iqstep)
c$$$        comm_t3 = glsum(qctime3,1)/(np*iqstep) ! total get  /(np*iqstep)

        if (nid.eq.0) then

        if(iqstep.eq.1) write(6,*)'iqstep nstate
     $gs_op get total ham lin fourier gs_op get total ham lin fourier'
         write(6,91) iqstep,nstate, 
     $               qctime1,qctime3,
     $               qrtime1,qrtime2, qrtime3, qrtime4,
     $               comm_t1,comm_t3,              
     $               cpu_t1,cpu_t2,cpu_t3,cpu_t4              

 91      format(/,i10,i10,12e10.3,' CPU: L2  '  )

        endif ! nid=0
      endif

      return
      end

c-----------------------------------------------------------------------
      subroutine userchk_acc
      include 'SIZE'
      include 'QUANT'


c ... compute errors


      if (iqstep.le.10.or.mod(iqstep,100).eq.0) then

c$$$        cpu_t1  = glsum(qrtime1,1)/(np*iqstep) ! total cpu/(np*iqstep)
c$$$        cpu_t2  = glsum(qrtime2,1)/(np*iqstep) ! hamiltonian/(np*iqstep)
c$$$        cpu_t3  = glsum(qrtime3,1)/(np*iqstep) ! linblad/(np*iqstep)
c$$$        cpu_t4  = glsum(qrtime4,1)/(np) ! fourier/(np)
c$$$
c$$$        comm_t1 = glsum(qctime1,1)/(np*iqstep) ! total gs_op/(np*iqstep)
c$$$        comm_t3 = glsum(qctime3,1)/(np*iqstep) ! total get  /(np*iqstep)

        if (nid.eq.0) then

        if(iqstep.eq.1) write(6,*)'iqstep level numqd numsp nstate
     $gs_op get total ham lin fourier gs_op get total ham lin fourier'
         write(6,91) iqstep, level,numqd,numsp,nstate, 
     $               qctime1,qctime3,
     $               qrtime1,qrtime2, qrtime3, qrtime4,
     $               comm_t1,comm_t3,    
     $               cpu_t1,cpu_t2,cpu_t3,cpu_t4    

 91      format(/,i10,3i7,i10,12e10.3,' CPU: L2  '  )

        endif ! nid=0
      endif

      return
      end 

c-----------------------------------------------------------------------
