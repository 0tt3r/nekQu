c----------------------------------------------------------------------
C
c  USER SPECIFIED ROUTINES:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine useriniQ
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'QUANT'
      include 'OPERATORS'
      include 'mpif.h'

      !Create variables to store operators
      !p = +, m = -
      !gpgp => |g+><g+|, gmgm => |g-><g-|, g0g0 => |g0><g0|, etc
      !nv hold all the vector state:
      !nv(1) = |g0> = g0, nv(2)=|e+>=ep, nv(3)=|e->=em

!      integer nv,nvt,nvn,nv_p_nvt
!      integer a,at,an,a_at,a_p_at
!      integer sig_g1,sig_g2,sig_e1,sig_e2
      
      integer jc(1200),ic(1200),nnz_c,ii
      integer N_th,num_phon,min_phonon_num !number of phonons
      !parameters
      real kappa
      real c(1200)
      !Units
      real kHz,MHz,GHz,THz,Hz,ns,us
      !Read the simple input
c$$$      if(nid.eq.0) then
c$$$      open(unit=2,file='quantInput')
c$$$      read(2,*) fluence,g_couple,g_couple2,g_couple3
c$$$      close(unit=2)
c$$$      endif
c$$$      call MPI_BCAST(fluence,1,MPI_REAL8,0,MPI_COMM_WORLD,IERR)
c$$$      call MPI_BCAST(g_couple,1,MPI_REAL8,0,MPI_COMM_WORLD,IERR)
c$$$      call MPI_BCAST(g_couple2,1,MPI_REAL8,0,MPI_COMM_WORLD,IERR)
c$$$      call MPI_BCAST(g_couple3,1,MPI_REAL8,0,MPI_COMM_WORLD,IERR)

      
      timeunit= 2.418884326505e-17 !in a.u.
      ns = 1e-9/timeunit
      us = 1e-6/timeunit
      

      
!Initial state 1/3 1/3 1/3 in ground state 10 in phonon
!     For n=16
!      timemax     = 0.0003e-6/timeunit
!      nqstep      = 90

!       for n=32
c$$$      timemax     = 0.3e-6/timeunit
c$$$      nqstep      = 18000


      call quantum_setup_initialize()
      timemax     = 1.e-6/timeunit
      nqstep      = 100000
      nqstep_print = 100000
      num_phon = 10

      print_during_run = .true.
!     Create basic operators
      call quantum_create_op(num_phon,a,at,an)  


      pi          = 4.*ATAN(1.0)      


      N_th = 2   !Very cold
      
      call quantum_set_minimum_op(0,an)

      call quantum_finalize_op_csr()
      nnzmax = nstate2*nstate
      call quantum_combine_op_csr(a,at,1,a_at)

!Oscillator terms
      !w_m at a
      call quantum_add_to_ham_csr(an,1.0,0)      

      call quantum_ham_finalize_csr()

      call quantum_kron_ham()


      !Lindblad terms
      !L_{i,f} = -2*|f><i|rho|i><f| + |i><i|rho + rho|i><i|
      !Translated to lin add:
      !      quantum_lin_add(|f><|i|,|i><i|,scalar)


c$$$
c$$$
c$$$      !Mechanical resonator dissipation
c$$$

      kappa = 1*(N_th+1)
      call quantum_lin_add(a,an,-kappa)

      kappa = 1*N_th
      call quantum_lin_add(at,a_at,-kappa)


!     Do lin_add_trans to get lin_comb_op to be correct
!     for preconditioning - NOT A GOOD WAY TO DO THIS
!      call quantum_lin_add_trans(a,an,-prefactor)
c$$$!      print*,'after lin_add2'
c$$$
      call quantum_lin_finalize()
      call quantum_kron_lin()
      call exitt()
!      call make_hamiltonian_and_lin(min_phonon_num)

!      call cem_quantum3_propagation_exp
!      call cem_quantum3_steadystate_cg
      call cem_quantum3_steadystate_gmres
!      call cem_quantum3_propagation_rk
!      call cem_quantum3_propagation_pece
      if(nid.eq.0) print*,rho_r(1,1)

      return
      end


c-----------------------------------------------------------------------
      subroutine make_hamiltonian_and_lin(min_phonon_num)
      implicit none
      include 'SIZE'
      include 'QUANT'
      include 'OPERATORS'

      integer min_phonon_num
      integer N_th,num_phon !number of phonons
      !parameters
      real w_m,D_e,Omega,gamma_eff,lambda_eff,lambda_s
      real keg,Q,prefactor,alpha,gamma_par

      !Units
      real kHz,MHz,GHz,THz,Hz,ns,us

      GHz = 1.519827e-7 !In AU
      MHz = GHz*1e-3
      kHz = MHz*1e-3
      THz = GHz*1e3
      Hz  = kHz*1e-3
      pi          = 4.*ATAN(1.0)      


      w_m = 475*MHz !Mechanical resonator frequency
      gamma_eff = 145*MHz !Effective dissipation rate
      lambda_s  = 1.06*kHz
      alpha      = 0.0135
      lambda_eff = lambda_s*sqrt(alpha)!*sqrt(number_nv)
      gamma_par = 167*MHz
      keg = 100*MHz !Relaxation from excited to ground
      Q   = 10**6  !Mechanical resonator quality factor
      Q   = 10**6! Q factor artifical - 3 phonons

      N_th = 13200 ! Room temperature
      N_th = 100   !Very cold
      
!     Create basic operators
!      call quantum_set_minimum_op(min_phonon_num,an)

      call quantum_finalize_op_csr()


      call quantum_combine_op_csr(a,at,1,a_at)

!Oscillator terms
      !w_m at a
      call quantum_add_to_ham_csr(an,w_m,0)      

      !w_m |e><e|
      call quantum_add_to_ham_csr(nvn,w_m,0)
      
      call quantum_combine_op_csr(a,at,0,a_p_at)
      call quantum_combine_op_csr(nv,nvt,0,nv_p_nvt)
      !Sigma_e term = lambda_eff (|e><g| + |g><e|)(a+at)
      call quantum_combine_op_csr(nv_p_nvt,a_p_at,1,sig_e1)
      call quantum_add_to_ham_csr(sig_e1,lambda_eff,0)      


      call quantum_ham_finalize_csr()

      !Lindblad terms
      !L_{i,f} = -2*|f><i|rho|i><f| + |i><i|rho + rho|i><i|
      !Translated to lin add:
      !      quantum_lin_add(|f><|i|,|i><i|,scalar)

      !Gamma_eff terms
      !-Gamma_eff/2 *  L_{e,g}
      call quantum_lin_add(nv,nvn,-gamma_eff/2)
!      call quantum_lin_add(nvn,nvn,-gamma_par/2)
!      call quantum_lin_add(nv,nv,-gamma_par/2)
c$$$      
c$$$
c$$$
c$$$      !Mechanical resonator dissipation
      prefactor = w_m/(2*Q)*(N_th+1)
      call quantum_lin_add(a,an,-prefactor)
c$$$
      print*,'prefactor: ',prefactor/GHz,w_m/GHz,prefactor/w_m
      prefactor = w_m/(2*Q) *N_th
!      call quantum_lin_add(at,a_at,-prefactor)
c$$$
!      call quantum_lin_add_trans(a,an,-prefactor)
c$$$!      print*,'after lin_add2'
c$$$
      call quantum_lin_finalize()


      return 
      end

c-----------------------------------------------------------------------
      subroutine usertimedep(pulse)
      implicit none
      include 'SIZE'
      include 'QUANT'
      real pulse
      real alpha

      alpha = 2 * log(2.0)/ (pulse_duration)**2
      if(rwa.eqv..true.) then
         pulse = 100
      else
         pulse = energy0_pls/2.0*exp(-alpha*(time-pulse_t_0)**2)
     $        *cos(pulse_omega_0*time)
      endif

!      if(nid.eq.1) then
!      print*,'1',time*timeunit,pulse
 !     print*,'2',eps_med,c_speed,eesu_per_au,timeunit,pi,time

!      endif
      return
      end

c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'QUANT'


c ... compute errors


      if (iqstep.le.10.or.mod(iqstep,100).eq.0) then

c$$$        cpu_t1  = glsum(qrtime1,1)/(np*iqstep) ! total cpu/(np*iqstep)
c$$$        cpu_t2  = glsum(qrtime2,1)/(np*iqstep) ! hamiltonian/(np*iqstep)
c$$$        cpu_t3  = glsum(qrtime3,1)/(np*iqstep) ! linblad/(np*iqstep)
c$$$        cpu_t4  = glsum(qrtime4,1)/(np) ! fourier/(np)
c$$$
c$$$        comm_t1 = glsum(qctime1,1)/(np*iqstep) ! total gs_op/(np*iqstep)
c$$$        comm_t3 = glsum(qctime3,1)/(np*iqstep) ! total get  /(np*iqstep)

        if (nid.eq.0) then

        if(iqstep.eq.1) write(6,*)'iqstep nstate
     $gs_op get total ham lin fourier gs_op get total ham lin fourier'
         write(6,91) iqstep,nstate, 
     $               qctime1,qctime3,
     $               qrtime1,qrtime2, qrtime3, qrtime4,
     $               comm_t1,comm_t3,              
     $               cpu_t1,cpu_t2,cpu_t3,cpu_t4              

 91      format(/,i10,i10,12e10.3,' CPU: L2  '  )

        endif ! nid=0
      endif

      return
      end

c-----------------------------------------------------------------------
      subroutine userchk_acc
      include 'SIZE'
      include 'QUANT'


c ... compute errors


      if (iqstep.le.10.or.mod(iqstep,100).eq.0) then

c$$$        cpu_t1  = glsum(qrtime1,1)/(np*iqstep) ! total cpu/(np*iqstep)
c$$$        cpu_t2  = glsum(qrtime2,1)/(np*iqstep) ! hamiltonian/(np*iqstep)
c$$$        cpu_t3  = glsum(qrtime3,1)/(np*iqstep) ! linblad/(np*iqstep)
c$$$        cpu_t4  = glsum(qrtime4,1)/(np) ! fourier/(np)
c$$$
c$$$        comm_t1 = glsum(qctime1,1)/(np*iqstep) ! total gs_op/(np*iqstep)
c$$$        comm_t3 = glsum(qctime3,1)/(np*iqstep) ! total get  /(np*iqstep)

        if (nid.eq.0) then

        if(iqstep.eq.1) write(6,*)'iqstep level numqd numsp nstate
     $gs_op get total ham lin fourier gs_op get total ham lin fourier'
         write(6,91) iqstep, level,numqd,numsp,nstate, 
     $               qctime1,qctime3,
     $               qrtime1,qrtime2, qrtime3, qrtime4,
     $               comm_t1,comm_t3,    
     $               cpu_t1,cpu_t2,cpu_t3,cpu_t4    

 91      format(/,i10,3i7,i10,12e10.3,' CPU: L2  '  )

        endif ! nid=0
      endif

      return
      end 

c-----------------------------------------------------------------------
