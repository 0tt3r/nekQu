C----------------------------------------------------------------------
c
c  USER SPECIFIED ROUTINES:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine useriniQ
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'QUANT'
      include 'mpif.h'

      !Create variables to store operators
      !p = +, m = -
      !gpgp => |g+><g+|, gmgm => |g-><g-|, g0g0 => |g0><g0|, etc
      !nv hold all the vector state:
      !nv(1) = |g+> = gp, nv(2)=|g0>=g0, nv(3)=|g->=gm
      !nv(4) = |e+> = ep, nv(5)=|e0>=e0, nv(6)=|e->=em
      !nv(7) = |s>  = s
      integer num_nv
      parameter (num_nv = 2)
      integer nv(7,num_nv),gp(num_nv),g0(num_nv),gm(num_nv)
      integer ep(num_nv),e0(num_nv),em(num_nv),s(num_nv)
      integer gpgp(num_nv),epep(num_nv),e0e0(num_nv)
      integer emem(num_nv),ss(num_nv),g0gm(num_nv)
      integer gmg0(num_nv),gmgp(num_nv),gpgm(num_nv)
      integer emep(num_nv),epem(num_nv),epgp(num_nv),e0g0(num_nv)
      integer gmem(num_nv),gpep(num_nv),emgm(num_nv),gmgm(num_nv)
      integer g0g0(num_nv),gpg0(num_nv)
      integer sep(num_nv),sem(num_nv),gms(num_nv),gps(num_nv)
      integer g0e0(num_nv),se0(num_nv),g0s(num_nv),g0gp(num_nv)
      integer a,at,an,a_at,a_p_at
      integer sig_e1(num_nv),sig_e2(num_nv)
      integer i,j
      
      integer N_th,num_phon !number of phonons
      !parameters
      real w_m,E_e,E_s,D_e,Omega,gamma_opt,lambda_g,lambda_e,lambda_s
      real k42,k31,k45,k35,k52,k51,Tg2,Te2,Tg1,Q,prefactor

      !Units
      real kHz,MHz,GHz,THz,ns,us
      !Read the simple input
c$$$      if(nid.eq.0) then
c$$$      open(unit=2,file='quantInput')
c$$$      read(2,*) fluence,g_couple,g_couple2,g_couple3
c$$$      close(unit=2)
c$$$      endif
c$$$      call MPI_BCAST(fluence,1,MPI_REAL8,0,MPI_COMM_WORLD,IERR)
c$$$      call MPI_BCAST(g_couple,1,MPI_REAL8,0,MPI_COMM_WORLD,IERR)
c$$$      call MPI_BCAST(g_couple2,1,MPI_REAL8,0,MPI_COMM_WORLD,IERR)
c$$$      call MPI_BCAST(g_couple3,1,MPI_REAL8,0,MPI_COMM_WORLD,IERR)
      GHz = 1.519827e-7 !In AU
      MHz = GHz*1e-3
      kHz = MHz*1e-3
      THz = GHz*1e3
      pi          = 4.*ATAN(1.0)      

      
      timeunit= 2.418884326505e-17 !in a.u.
      ns = 1e-9/timeunit
      us = 1e-6/timeunit
      
      w_m = 475*MHz*2*pi !Mechanical resonator frequency
      E_e = 0*480*THz*2*pi !NV center excited state energy
      E_s = 0*370*THz*2*pi !Nv center singlet energy
      D_e = 0*1.42*GHz*2*pi !Used to be 1.52? NV excited state zero field splitting
      Omega = 60*MHz*2*pi !Magnetic driving field
      gamma_opt = 130*MHz !Optical pumping rate
      lambda_s = 100*1.06*kHz*2*pi
      lambda_g = 300*kHz*2*pi !Ground state spin-strain coupling
!      lambda_e = 10*lambda_g   !Excited state spin-strain coupling
      k42 = 65.3*MHz !Relaxation from excited to ground
      k31 = 64.9*MHz !Relaxation from excited to ground
      k45 = 79.8*MHz !Relaxation from excited to singlet
      k35 = 10.6*MHz !Relaxation from excited to singlet
      k52 = 2.61*MHz !Relaxation from singlet to ground
      k51 = 3.00*MHz !Relaxation from singlet to ground
      Tg2 = 59*ns !Ground state longitudinal spin relaxation
      Te2 = 6*ns   !Excited state longitudinal spin relaxation
!      Tg1 = 100*us !Ground state transverse spin relaxation
      Q   = 10**6  !Mechanical resonator quality factor
      Q   = 10**6
 !Q factor artifical - 3 phonons

      N_th = 10  !Very cold

      
!Initial state 1/3 1/3 1/3 in ground state 10 in phonon
!     For n=16
!      timemax     = 0.0003e-6/timeunit
!      nqstep      = 90

!       for n=32
c$$$      timemax     = 0.3e-6/timeunit
c$$$      nqstep      = 18000

      call quantum_setup_initialize()

      timemax     = 100.e-6/timeunit
      nqstep      = 10000000
      nqstep_print = 3000
      print_during_run = .true.
      num_phon = 16

!     Create basic operators

      call quantum_create_op(num_phon,a,at,an)  
      do i=1,num_nv
         call quantum_create_vec(7,nv(1,i))  
      enddo

      call quantum_finalize_op_csr()


      do i=1,num_nv
         gp(i) = nv(1,i)             !|g+>
         g0(i) = nv(2,i)             !|g0>
         gm(i) = nv(3,i)             !|g->
         ep(i) = nv(4,i)             !|e+>
         e0(i) = nv(5,i)             !|e0>
         em(i) = nv(6,i)             !|e->
         s(i)  = nv(7,i)             !|s>
      enddo

!     Combine vec operators to get terms for the hamiltonian/lindblad
      do i=1,num_nv
         call quantum_combine_vec(gp(i),gp(i),gpgp(i))
         call quantum_combine_vec(ep(i),ep(i),epep(i))
         call quantum_combine_vec(e0(i),e0(i),e0e0(i))
         call quantum_combine_vec(em(i),em(i),emem(i))
         call quantum_combine_vec(s(i),s(i),ss(i))
         call quantum_combine_vec(g0(i),gm(i),g0gm(i))
         call quantum_combine_vec(gm(i),g0(i),gmg0(i))
         call quantum_combine_vec(gm(i),gp(i),gmgp(i))
         call quantum_combine_vec(gp(i),gm(i),gpgm(i))
         call quantum_combine_vec(em(i),ep(i),emep(i))
         call quantum_combine_vec(ep(i),em(i),epem(i))
         call quantum_combine_vec(ep(i),gp(i),epgp(i))
         call quantum_combine_vec(e0(i),g0(i),e0g0(i))
         call quantum_combine_vec(gm(i),em(i),gmem(i))
         call quantum_combine_vec(gp(i),ep(i),gpep(i))
         call quantum_combine_vec(em(i),gm(i),emgm(i))
         call quantum_combine_vec(gm(i),gm(i),gmgm(i))
         call quantum_combine_vec(g0(i),g0(i),g0g0(i))
         call quantum_combine_vec(s(i),ep(i),sep(i))
         call quantum_combine_vec(s(i),em(i),sem(i))
         call quantum_combine_vec(gm(i),s(i),gms(i))
         call quantum_combine_vec(gp(i),s(i),gps(i))
         call quantum_combine_vec(s(i),e0(i),se0(i))
         call quantum_combine_vec(g0(i),s(i),g0s(i))
         call quantum_combine_vec(g0(i),e0(i),g0e0(i))
         call quantum_combine_vec(g0(i),gp(i),g0gp(i))
         call quantum_combine_vec(gp(i),g0(i),gpg0(i))
      enddo

      call quantum_combine_op_csr(a,at,1,a_at)

       !Oscillator terms
      !w_m at a
      call quantum_add_to_ham_csr(an,w_m,0)      
      !w_m |g+><g+|
!      call quantum_add_to_ham_csr(gpgp,w_m,0)
      !(E_e + w_m) |e+><e+|
      do i=1,num_nv
         call quantum_add_to_ham_csr(epep(i),(E_e+w_m),0)
      !(E_e - D_e) |e0><e0|
!      call quantum_add_to_ham_csr(e0e0,(E_e-D_e),0)
      !E_e |e-><e-|
!      call quantum_add_to_ham_csr(emem,E_e,0)
      !E_s |s><s|
!      call quantum_add_to_ham_csr(ss,E_s,0)

      !Magnetic field driving term Omega/2(|g0><g-| + |g-><g0|)
         call quantum_add_to_ham_csr(g0gm(i),omega/2,0)
         call quantum_add_to_ham_csr(gmg0(i),omega/2,0)
      enddo
      !Sigma_g term = lambda_g (|g-><g+| + |g+><g-|) (a+at)
      call quantum_combine_op_csr(a,at,0,a_p_at)

c$$$      call quantum_combine_op_csr(gmgp,a_p_at,1,sig_g1)
c$$$
c$$$      call quantum_combine_op_csr(gpgm,a_p_at,1,sig_g2)
c$$$      call quantum_add_to_ham_csr(sig_g1,lambda_g,0)      
c$$$      call quantum_add_to_ham_csr(sig_g2,lambda_g,0)      

      !Sigma_e term = lambda_e (|e-><e+| + |e+><e-|)(a+at)
      do i=1,num_nv
         call quantum_combine_op_csr(emep(i),a_p_at,1,sig_e1(i))
         call quantum_combine_op_csr(epem(i),a_p_at,1,sig_e2(i))
         call quantum_add_to_ham_csr(sig_e1(i),lambda_s,0)      
         call quantum_add_to_ham_csr(sig_e2(i),lambda_s,0)     
      enddo
      call quantum_ham_finalize_csr()

      call quantum_print_ham()

      !Lindblad terms
      !L_{i,f} = -2*|f><i|rho|i><f| + |i><i|rho + rho|i><i|
      !Translated to lin add:
      !      quantum_lin_add(|f><|i|,|i><i|,scalar)

      !Gamma_opt terms
      !-Gamma_opt/2 * sum_{i=+,0,-} L_{gi,ei}
      do i=1,num_nv
         call quantum_lin_add(epgp(i),gpgp(i),-gamma_opt/2)
         call quantum_lin_add(emgm(i),gmgm(i),-gamma_opt/2)
         call quantum_lin_add(e0g0(i),g0g0(i),-gamma_opt/2)
      
      !k42 terms
      !-k42/2 * sum_{i=+,-} L_{ei,gi}
         call quantum_lin_add(gpep(i),epep(i),-k42/2)
         call quantum_lin_add(gmem(i),emem(i),-k42/2)

      !k45 terms
      !-k45/2 * sum_{i=+,-} L_{ei,s}
         call quantum_lin_add(sem(i),emem(i),-k45/2)
         call quantum_lin_add(sep(i),epep(i),-k45/2)

      !k52 terms
      !-k52/2 * sum_{i=+,-} L_{s,gi}
         call quantum_lin_add(gms(i),ss(i),-k52/2)
         call quantum_lin_add(gps(i),ss(i),-k52/2)

      !k31 term
      !-k31/2 L_{e0,g0}
         call quantum_lin_add(g0e0(i),e0e0(i),-k31/2)

      !k35 term
      !-k35/2 L_{e0,s}
         call quantum_lin_add(se0(i),e0e0(i),-k35/2)

      !k51 term
      !-k51/2 L_{s,g0}
         call quantum_lin_add(g0s(i),ss(i),-k51/2)

      !T^g_2 term
      !-1/(2*T^g_2) sum_{i=g+,g-} L_{i,i}
         call quantum_lin_add(gpgp(i),gpgp(i),-1/(2*tg2))
         call quantum_lin_add(gmgm(i),gmgm(i),-1/(2*tg2))
      
      !T^e_2 term
      !-1/(2*T^e_2) sum_{i=e+,e-} L_{i,i}
         call quantum_lin_add(epep(i),epep(i),-1/(2*te2))
         call quantum_lin_add(e0e0(i),e0e0(i),-1/(2*te2))
         call quantum_lin_add(emem(i),emem(i),-1/(2*te2))
         
      !T^g_1 term
      !-1/(2*T^g_1) sum_{i=+,0,-} sum_{j=+,0,-} (1-delta_ij) L_{gi,gj}
c$$$      call quantum_lin_add(gpgm,gmgm,-1/(2*tg1))
c$$$      call quantum_lin_add(gpg0,g0g0,-1/(2*tg1))
c$$$      call quantum_lin_add(g0gp,gpgp,-1/(2*tg1))
c$$$      call quantum_lin_add(g0gm,gmgm,-1/(2*tg1))
c$$$      call quantum_lin_add(gmgp,gpgp,-1/(2*tg1))
c$$$      call quantum_lin_add(gmg0,g0g0,-1/(2*tg1))
      enddo


      !Mechanical resonator dissipation
      prefactor = w_m/(2*Q)*(N_th+1)
      call quantum_lin_add(a,an,-prefactor)
!      print*,'after lin_add'
      prefactor = w_m/(2*Q)*N_th
      call quantum_lin_add(at,a_at,-prefactor)

!      call quantum_lin_add_trans(a,an,-prefactor)
!      print*,'after lin_add2'

      call quantum_lin_finalize()
!      call cem_quantum3_propagation_exp
      call cem_quantum3_steadystate_gmres
!      call cem_quantum3_propagation_rk
!      call cem_quantum3_propagation_pece
      return
      end

c-----------------------------------------------------------------------
      subroutine usertimedep(pulse)
      implicit none
      include 'SIZE'
      include 'QUANT'
      real pulse
      real alpha

      alpha = 2 * log(2.0)/ (pulse_duration)**2
      if(rwa.eqv..true.) then
         pulse = 100
      else
         pulse = energy0_pls/2.0*exp(-alpha*(time-pulse_t_0)**2)
     $        *cos(pulse_omega_0*time)
      endif

!      if(nid.eq.1) then
!      print*,'1',time*timeunit,pulse
 !     print*,'2',eps_med,c_speed,eesu_per_au,timeunit,pi,time

!      endif
      return
      end

c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'QUANT'


c ... compute errors


      if (iqstep.le.10.or.mod(iqstep,100).eq.0) then

c$$$        cpu_t1  = glsum(qrtime1,1)/(np*iqstep) ! total cpu/(np*iqstep)
c$$$        cpu_t2  = glsum(qrtime2,1)/(np*iqstep) ! hamiltonian/(np*iqstep)
c$$$        cpu_t3  = glsum(qrtime3,1)/(np*iqstep) ! linblad/(np*iqstep)
c$$$        cpu_t4  = glsum(qrtime4,1)/(np) ! fourier/(np)
c$$$
c$$$        comm_t1 = glsum(qctime1,1)/(np*iqstep) ! total gs_op/(np*iqstep)
c$$$        comm_t3 = glsum(qctime3,1)/(np*iqstep) ! total get  /(np*iqstep)

        if (nid.eq.0) then

        if(iqstep.eq.1) write(6,*)'iqstep nstate
     $gs_op get total ham lin fourier gs_op get total ham lin fourier'
         write(6,91) iqstep,nstate, 
     $               qctime1,qctime3,
     $               qrtime1,qrtime2, qrtime3, qrtime4,
     $               comm_t1,comm_t3,              
     $               cpu_t1,cpu_t2,cpu_t3,cpu_t4              

 91      format(/,i10,i10,12e10.3,' CPU: L2  '  )

        endif ! nid=0
      endif

      return
      end

c-----------------------------------------------------------------------
      subroutine userchk_acc
      include 'SIZE'
      include 'QUANT'


c ... compute errors


      if (iqstep.le.10.or.mod(iqstep,100).eq.0) then

c$$$        cpu_t1  = glsum(qrtime1,1)/(np*iqstep) ! total cpu/(np*iqstep)
c$$$        cpu_t2  = glsum(qrtime2,1)/(np*iqstep) ! hamiltonian/(np*iqstep)
c$$$        cpu_t3  = glsum(qrtime3,1)/(np*iqstep) ! linblad/(np*iqstep)
c$$$        cpu_t4  = glsum(qrtime4,1)/(np) ! fourier/(np)
c$$$
c$$$        comm_t1 = glsum(qctime1,1)/(np*iqstep) ! total gs_op/(np*iqstep)
c$$$        comm_t3 = glsum(qctime3,1)/(np*iqstep) ! total get  /(np*iqstep)

        if (nid.eq.0) then

        if(iqstep.eq.1) write(6,*)'iqstep level numqd numsp nstate
     $gs_op get total ham lin fourier gs_op get total ham lin fourier'
         write(6,91) iqstep, level,numqd,numsp,nstate, 
     $               qctime1,qctime3,
     $               qrtime1,qrtime2, qrtime3, qrtime4,
     $               comm_t1,comm_t3,    
     $               cpu_t1,cpu_t2,cpu_t3,cpu_t4    

 91      format(/,i10,3i7,i10,12e10.3,' CPU: L2  '  )

        endif ! nid=0
      endif

      return
      end 

c-----------------------------------------------------------------------
